# 2-4.Proxy / Decorator Pattern
## 0. Client와 Server
 큰 개념으로 클라이언트와 서버의 개념을 보면, 클라이언트는 서버에 필요한 것을 요청하고 서버는 클라이언트의 요청을 처리하는 것 이다.  
이 개념을 객체에 적용하면, 요청하는 객체는 클라이언트가 되고, 요청을 처리하는 객체는 서버가 될 수 있다.  

## 1. Proxy
  
#### 직접호출    
클라이언트가 서버를 '직접' 호출하여 결과를 받는다.  
client - > server
#### 간접호출   
클라이언트가 요청한 결과를 서버에 직접 요청하는 것이 아닌 어떤 대리자를 통해서 대신 '간접' 적으로 서버에 요청할 수 있다. 그리고 이 간접으로 요청을 처리해 주는 대리자를 'Proxy'라고 한다.  
client -> proxy -> server
  
#### 프록시 기능   
- **접근제어** :  권한에 따른 접근 차단, 캐싱 지연로딩을 수행  
- **부가 기능 추가** : 서버에 기능에 다른 기능을 추가  
- **프록시 체인** :  대리자가 또 다른 대리자를 호출  

#### 프록시 객체 특징
 - 객체에서 프록시가 되려면, 클라이언트는 서버에게 요청을 한 것인지, 프록시에게 요청을 한 것인지 조차 몰라야 한다.  
 - 서버와 프록시는 같은 인터페이스를 사용해야 한다.
 - 클라이언트가 사용하는 서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.  


## 2. Proxy Pattern / Decorator Pattern
프록시 패턴과 데코레이터 패턴은 그 모양이 거의 같고, 상황에 따라 똑같을 때도 있다.  
둘다 프록시를 사용하는 방법이지만 GOF 디자인 패턴에서는 이 둘을 **'의도'** 에 따라서 프록시
패턴과 데코레이터 패턴으로 구분한다.
  
- 프록시 패턴 :다른 객체에 대한 접근을 제어하기 위해 대리자를 제공 **(접근 제어가 목적)**  
- 데코레이터 패턴 : 객체에 추가 책임(기능)을 동적으로 추가하고, 기능 확장을 위한 유연한 대안 제공 새로운 기능 추가가 목적 **(새로운 기능 추가가 목적)**

#### 예제 코드  
- v1 : 인퍼페이스와 구현 클래스 수동등록
- v2 : 인터페이스 없는 구체 클래스 수동등록
- v3 : 컴포넌트 자동 빈 등록


